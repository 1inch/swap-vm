---
globs: test/**/*
alwaysApply: false
---

# SwapVM Test Writing Guidelines

## File Structure & Naming

### Test File Naming
- Unit tests: `<InstructionName>.t.sol` (e.g., `XYCSwap.t.sol`, `Fee.t.sol`)
- Aqua integration tests: `<Feature>Aqua.t.sol` (e.g., `XYCSwapAqua.t.sol`)
- Invariant tests: `test/invariants/<Feature>Invariants.t.sol`
- Gas benchmarks: `test/gas/<Feature>Gas.t.sol`
- Helpers: `test/helpers/`, `test/utils/`, `test/mocks/`

### Test Contract Structure
```solidity
// SPDX-License-Identifier: LicenseRef-Degensoft-SwapVM-1.1
pragma solidity 0.8.30;

/// @custom:license-url https://github.com/1inch/swap-vm/blob/main/LICENSES/SwapVM-1.1.txt
/// @custom:copyright Â© 2025 Degensoft Ltd

import { Test, console } from "forge-std/Test.sol";
// ... other imports

contract MyFeatureTest is Test, OpcodesDebug {
    using ProgramBuilder for Program;
    
    // State variables
    SwapVMRouter public swapVM;
    MockToken public tokenA;
    MockToken public tokenB;
    
    address public maker;
    uint256 public makerPrivateKey;
    address public taker = makeAddr("taker");
    
    constructor() OpcodesDebug(address(new Aqua())) {}
    
    function setUp() public { ... }
    
    // ========================================
    // HELPER FUNCTIONS
    // ========================================
    
    function _makeOrder(...) internal view returns (ISwapVM.Order memory) { ... }
    function _signAndPack(...) internal view returns (bytes memory) { ... }
    
    // ========================================
    // BASIC TESTS
    // ========================================
    
    function test_Feature_BasicCase() public { ... }
    
    // ========================================
    // EDGE CASE TESTS
    // ========================================
    
    function test_Feature_EdgeCase() public { ... }
}
```

## Test Function Naming

### Pattern: `test_<Feature>_<Scenario>[_<Variation>]`

```solidity
// Basic functionality
function test_XYCSwap_BasicSwap_NoFee() public { }
function test_XYCSwap_BasicSwap_WithFee() public { }

// Edge cases
function test_XYCSwap_SmallAmounts() public { }
function test_XYCSwap_LargeAmounts() public { }
function test_XYCSwap_AsymmetricPool() public { }

// ExactIn vs ExactOut
function test_Feature_ExactIn_Basic() public { }
function test_Feature_ExactOut_Basic() public { }

// Invariants
function test_Feature_SplitInvariance_TwoSwaps() public { }
function test_Feature_RoundingInvariants() public { }

// Gas benchmarks
function test_gas_XYCSwap_swap_exactIn() public { }
function test_gas_XYCSwap_quote_exactOut() public { }
```

## Standard Setup Pattern

```solidity
function setUp() public {
    // 1. Create maker with deterministic private key
    makerPrivateKey = 0x1234;
    maker = vm.addr(makerPrivateKey);
    
    // 2. Deploy SwapVM router
    swapVM = new SwapVMRouter(address(0), address(0), "SwapVM", "1.0.0");
    
    // 3. Deploy mock tokens
    tokenA = new MockToken("Token A", "TKA");
    tokenB = new MockToken("Token B", "TKB");
    
    // 4. Mint tokens to maker and taker
    tokenA.mint(maker, 1000000e18);
    tokenB.mint(maker, 1000000e18);
    tokenA.mint(taker, 1000000e18);
    tokenB.mint(taker, 1000000e18);
    
    // 5. Approve swapVM for both parties
    vm.prank(maker);
    tokenA.approve(address(swapVM), type(uint256).max);
    vm.prank(maker);
    tokenB.approve(address(swapVM), type(uint256).max);
    
    vm.prank(taker);
    tokenA.approve(address(swapVM), type(uint256).max);
    vm.prank(taker);
    tokenB.approve(address(swapVM), type(uint256).max);
}
```

## Order Building Pattern

Use `ProgramBuilder` and `MakerTraitsLib` for constructing orders:

```solidity
function _makeOrder(uint256 balanceA, uint256 balanceB, uint32 alpha) internal view returns (ISwapVM.Order memory) {
    Program memory program = ProgramBuilder.init(_opcodes());
    
    bytes memory bytecode = bytes.concat(
        // 1. Balances instruction (required for AMM)
        program.build(_dynamicBalancesXD, BalancesArgsBuilder.build(
            dynamic([address(tokenA), address(tokenB)]),
            dynamic([balanceA, balanceB])
        )),
        // 2. Optional fee instructions
        // program.build(_flatFeeAmountInXD, FeeArgsBuilder.buildFlatFee(fee)),
        // 3. Swap instruction
        program.build(_xycSwapXD)
        // OR with args:
        // program.build(_xycSwapStrictAdditiveXD, XYCSwapStrictAdditiveArgsBuilder.build(alpha))
    );
    
    return MakerTraitsLib.build(MakerTraitsLib.Args({
        maker: maker,
        shouldUnwrapWeth: false,
        useAquaInsteadOfSignature: false,
        allowZeroAmountIn: false,
        receiver: address(0),
        hasPreTransferInHook: false,
        hasPostTransferInHook: false,
        hasPreTransferOutHook: false,
        hasPostTransferOutHook: false,
        preTransferInTarget: address(0),
        preTransferInData: "",
        postTransferInTarget: address(0),
        postTransferInData: "",
        preTransferOutTarget: address(0),
        preTransferOutData: "",
        postTransferOutTarget: address(0),
        postTransferOutData: "",
        program: bytecode
    }));
}
```

## Taker Data Pattern

```solidity
function _signAndPack(ISwapVM.Order memory order, bool isExactIn, uint256 threshold) internal view returns (bytes memory) {
    bytes32 orderHash = swapVM.hash(order);
    (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
    bytes memory signature = abi.encodePacked(r, s, v);
    
    bytes memory thresholdData = threshold > 0 ? abi.encodePacked(bytes32(threshold)) : bytes("");
    
    return abi.encodePacked(TakerTraitsLib.build(TakerTraitsLib.Args({
        taker: address(0),
        isExactIn: isExactIn,
        shouldUnwrapWeth: false,
        isStrictThresholdAmount: false,
        isFirstTransferFromTaker: false,
        useTransferFromAndAquaPush: false,
        threshold: thresholdData,
        to: taker,
        deadline: 0,
        hasPreTransferInCallback: false,
        hasPreTransferOutCallback: false,
        preTransferInHookData: "",
        postTransferInHookData: "",
        preTransferOutHookData: "",
        postTransferOutHookData: "",
        preTransferInCallbackData: "",
        preTransferOutCallbackData: "",
        instructionsArgs: "",
        signature: signature
    })));
}
```

## Snapshot/Revert Pattern for Comparisons

```solidity
function test_SplitInvariance() public {
    uint256 totalAmount = 100e18;
    
    // Method 1: Single swap
    uint256 snapshot = vm.snapshot();
    vm.prank(taker);
    (, uint256 singleSwapOut,) = swapVM.swap(order, tokenA, tokenB, totalAmount, takerData);
    
    // Method 2: Split swaps
    vm.revertTo(snapshot);
    vm.prank(taker);
    (, uint256 firstOut,) = swapVM.swap(order, tokenA, tokenB, 40e18, takerData);
    vm.prank(taker);
    (, uint256 secondOut,) = swapVM.swap(order, tokenA, tokenB, 60e18, takerData);
    
    // Assert: split should equal single
    assertApproxEqRel(firstOut + secondOut, singleSwapOut, 1e15, "Split invariance failed");
}
```

## Gas Benchmark Pattern

```solidity
function test_gas_Feature_swap_exactIn() public {
    (ISwapVM.Order memory order, bytes memory takerData) = _createOrder(true);
    
    vm.startSnapshotGas("Feature_swap_exactIn");
    swapVM.swap(order, address(tokenA), address(tokenB), SWAP_AMOUNT, takerData);
    vm.stopSnapshotGas();
}

// For pure math gas comparison:
function test_GasComparison_MathOnly() public {
    uint256 gasBefore = gasleft();
    uint256 result = MyMath.calculate(inputs);
    uint256 gasUsed = gasBefore - gasleft();
    
    console.log("Gas used:", gasUsed);
}
```

## Invariant Test Patterns

### Use existing invariant libraries:
- `RoundingInvariants` - Rounding accumulation exploits
- `CoreInvariants` - Symmetry, additivity, monotonicity
- `ExactInOutSymmetry` - ExactIn/ExactOut consistency

```solidity
import { RoundingInvariants } from "./invariants/RoundingInvariants.sol";
import { CoreInvariants } from "./invariants/CoreInvariants.t.sol";

// For custom invariant testing:
function test_Feature_RoundingInvariants() public {
    RoundingInvariants.assertNoAccumulationExploit(
        vm,
        swapVM,
        order,
        address(tokenA),
        address(tokenB),
        1e15,  // atomicAmount (use realistic amounts for 18-decimal precision)
        100,   // iterations
        takerData,
        _executeSwap
    );
}
```

## Console Logging Best Practices

```solidity
// Use section headers for clarity
console.log("\n========== TEST SECTION ==========");
console.log("Single swap output:", singleSwapOut);
console.log("Split swap output: ", splitSwapOut);
console.log("===================================\n");

// Forge console.log supports max 4 arguments:
console.log("Amount:", amount, "Gas:", gasUsed);  // OK - 4 args
// NOT: console.log("Amount:", a, "Gas:", g, "Out:", o);  // TOO MANY

// For more args, use multiple calls:
console.log("Amount:", amount);
console.log("Gas:", gasUsed, "Output:", output);
```

## Assertion Patterns

```solidity
// Exact equality
assertEq(actual, expected, "Values must match exactly");

// Approximate equality (absolute)
assertApproxEqAbs(actual, expected, 100, "Allow 100 wei difference");

// Approximate equality (relative) - tolerance in 1e18 scale (1e15 = 0.1%)
assertApproxEqRel(actual, expected, 1e15, "Allow 0.1% difference");

// Comparisons
assertGt(amountOut, 0, "Output must be positive");
assertLt(amountOut, maxOutput, "Output must be below max");
assertGe(amountIn, minRequired, "Input must meet minimum");
assertLe(currentAmount, initialAmount, "No profit from round-trip");
```

## Test Categories to Include

1. **Basic Functionality**: Happy path tests
2. **ExactIn vs ExactOut**: Both directions
3. **Edge Cases**: Small amounts, large amounts, asymmetric pools
4. **Split Invariance**: Single swap = sum of split swaps (for additive formulas)
5. **Rounding Invariants**: No accumulation exploits, no round-trip profits
6. **Gas Benchmarks**: Quote and swap operations
7. **Fee Variations**: No fee, with fee, high fee
8. **Error Cases**: Expected reverts with `vm.expectRevert()`

## Dynamic Array Utility

Use `dynamic()` helper for building token/balance arrays:

```solidity
import { dynamic } from "./utils/Dynamic.sol";

// Create address array
dynamic([address(tokenA), address(tokenB)])

// Create uint256 array  
dynamic([balanceA, balanceB])
```

## MockToken Pattern

```solidity
contract MockToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}
```

## Running Tests

```bash
# Run specific test
forge test --match-test "test_XYCSwap_BasicSwap" -vvv

# Run test contract
forge test --match-contract "XYCSwapTest"

# Run with gas snapshot
forge test --gas-report

# Update gas snapshot
forge snapshot
```
